ConcurrencyStudies.cpp revision 3.01 Build 1 built on Aug 11 2025 at 15:29:53

* ******************************************************************************************** *
* ******************************************************************************************** *
* **** Testing performance improvement by splitting summing integers into multiple threads *** *
* ******************************************************************************************** *
* ******************************************************************************************** *


Summing from 0 to 1,000,000,000                LATENCIES (in milliseconds)
Number of threads                        1           2          64         128         150         200
------------------------------
void sumUsingFunction()               2652        3473         829         547         533         546
void sumUsingFunctor()                2650        1438         459         433         443         441
void sumUsingLambdas()                2276        3282         873         747         701         724
void sumUsingAsyncFunction()          2645        1365         471         468         468         470
void sumUsingAsyncFunctor()           2806        1420         467         439         435         432
void sumUsingAsyncLambdas()           2223        1176         423         423         425         425



* ********************************************************* *
* ********************************************************* *
* * Testing concurrent access by threads to linear queues * *
* ********************************************************* *
* ********************************************************* *


  This version of the program simulates multiple producer threads concurrently
storing messages to a linear queue, which are simultaneously dequeued by
consumer threads.The consumer threads wait a random time, then enqueue the
messages into to a 'retired' queue.  The retired queue is unloaded sequentially
in the main thread after the concurrent consumer threads terminate.
The results of the tests indicate how many simultaneous attempts to access both
the producer queue and retired queue occurred between the consumer threads.

test #  0: out of order count: 486
test #  1: out of order count: 514
test #  2: out of order count: 494
test #  3: out of order count: 568
test #  4: out of order count: 543
test #  5: out of order count: 565
test #  6: out of order count: 545
test #  7: out of order count: 485
average number of collisions: 525
Default RingBufferTestObject constructor called
Default RingBufferTestObject constructor called
RingBufferTestObject constructor called with ID: 2
RingBufferTestObject constructor called with ID: 1
RingBufferTestObject constructor called with ID: 10
RingBufferTestObject destructor called on object with ID 10
pointer_buffer: 
flags:  FULL_false EMPTY_false OVERRUN_false UNDERRUN_false
error state: 0
    0:     dq 
    1:        
    2:  nq     
    3:        

object_buffer:  
flags:  FULL_false EMPTY_false OVERRUN_false UNDERRUN_false
error state: 0
    0:     dq 
    1:  nq     

in testRingBuffer()
returning from testRingBuffer()
RingBufferTestObject destructor called on object with ID -1
RingBufferTestObject destructor called on object with ID 10
RingBufferTestObject destructor called on object with ID 2
RingBufferTestObject destructor called on object with ID 1
ConcurrencyStudies.cpp exiting
